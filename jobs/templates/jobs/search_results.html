{% extends 'base.html' %}

{% block extra_css %}
<style>
  .search-container { position: relative; }
  .autocomplete-dropdown {
    position: absolute;
    top: 100%;
    left: 0;
    right: 0;
    background: white;
    border: 1px solid #ddd;
    border-top: none;
    border-radius: 0 0 4px 4px;
    max-height: 200px;
    overflow-y: auto;
    z-index: 1000;
    display: none;
  }
  .autocomplete-item {
    padding: 8px 12px;
    cursor: pointer;
    border-bottom: 1px solid #eee;
    font-size: 14px;
  }
  .autocomplete-item:hover {
    background-color: #f8f9fa;
  }
  .autocomplete-item:last-child {
    border-bottom: none;
  }
  .autocomplete-item.selected {
    background-color: #e9ecef;
  }
</style>
{% endblock %}

{% block content %}
<div class="container mt-4">
  <div class="d-flex justify-content-between align-items-center">
    <h2>Search results</h2>
    <div class="text-muted small">{{ jobs|length }} results</div>
  </div>

  <!-- Filters tab -->
  <div class="card mt-3">
    <div class="card-body">
      <form id="filters-form" method="get" class="row gx-2 gy-2 align-items-end">
        <div class="col-auto">
          <label class="form-label small">Query</label>
          <input type="text" name="q" value="{{ q }}" class="form-control form-control-sm" placeholder="keywords">
        </div>
        <div class="col-auto">
          <label class="form-label small">Location</label>
          <div class="search-container">
            <input id="filter-location" type="text" name="location" value="{{ location }}" class="form-control form-control-sm" placeholder="City, address or ZIP" autocomplete="off">
            <div id="autocomplete-dropdown" class="autocomplete-dropdown"></div>
          </div>
        </div>
        <div class="col-auto">
          <label class="form-label small">Distance</label>
          <select id="filter-radius" name="radius" class="form-select form-select-sm">
            <option value="">Any</option>
            <option value="5">Within 5 miles</option>
            <option value="10">Within 10 miles</option>
            <option value="25">Within 25 miles</option>
            <option value="50">Within 50 miles</option>
          </select>
        </div>
        <div class="col-auto">
          <input id="filter-lat" type="hidden" name="lat" value="">
          <input id="filter-lon" type="hidden" name="lon" value="">
          <button id="use-my-location-filter" class="btn btn-outline-secondary btn-sm">Use my location</button>
        </div>
        <div class="col-auto">
          <button type="submit" class="btn btn-primary btn-sm">Apply filters</button>
        </div>
        <div class="col-auto">
          <a href="{% url 'jobs:suggested_jobs' %}" class="btn btn-outline-success btn-sm">Recommend jobs based on my skills</a>
        </div>
      </form>
    </div>
  </div>

  {% if jobs %}
    <div class="row gy-3 mt-3">
      {% for job in jobs %}
        <div class="col-12">
          <div class="card">
            <div class="card-body d-flex justify-content-between align-items-start">
              <div>
                <h5 class="mb-1">{{ job.title }}</h5>
                <div class="text-muted small">{{ job.company }} â€” {{ job.location }}</div>
                <p class="mt-2 mb-0 text-truncate" style="max-height:3.6em; overflow:hidden;">{{ job.description }}</p>
                <div class="text-muted small mt-2">Posted {{ job.posted_at|date:"M d, Y" }}</div>
              </div>
              <div class="ms-3 d-flex flex-column align-items-end">
                <a href="{% url 'jobs:job_detail' job.pk %}" class="btn btn-outline-primary btn-sm mb-2">View</a>
                <a href="{% url 'jobs:apply' job.pk %}" class="btn btn-primary btn-sm">Apply</a>
              </div>
            </div>
          </div>
        </div>
      {% endfor %}
    </div>
  {% else %}
    <p class="text-muted mt-3">No jobs found matching your filters.</p>
  {% endif %}

  <div class="mt-4">
    <a href="/" class="btn btn-secondary">Back home</a>
  </div>
</div>
{% endblock %}

{% block extra_js %}
<script>
// MapBox API functions
async function geocodeQuery(query) {
  const MAPBOX_TOKEN = 'pk.eyJ1IjoiaGFpaGxlIiwiYSI6ImNtZnZkZWF0azA2YmkyeXBqOW15MnpyYmsifQ._VgiLAueIm7KWmZLY5hGTQ';
  
  if (!MAPBOX_TOKEN || MAPBOX_TOKEN === 'YOUR_MAPBOX_TOKEN') {
    try {
      const url = `https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(query)}`;
      const res = await fetch(url);
      const data = await res.json();
      return data[0] ? { display_name: data[0].display_name, lat: parseFloat(data[0].lat), lon: parseFloat(data[0].lon) } : null;
    } catch (e) { return null; }
  }
  
  try {
    const url = `https://api.mapbox.com/geocoding/v5/mapbox.places/${encodeURIComponent(query)}.json?access_token=${MAPBOX_TOKEN}&limit=1`;
    const res = await fetch(url);
    const data = await res.json();
    if (data.features && data.features.length > 0) {
      const item = data.features[0];
      return { display_name: item.place_name, lat: item.center[1], lon: item.center[0] };
    }
    return null;
  } catch (error) { return null; }
}

async function searchAddresses(query, limit = 5) {
  if (query.length < 3) return [];
  const MAPBOX_TOKEN = 'pk.eyJ1IjoiaGFpaGxlIiwiYSI6ImNtZnZkZWF0azA2YmkyeXBqOW15MnpyYmsifQ._VgiLAueIm7KWmZLY5hGTQ';
  
  if (!MAPBOX_TOKEN || MAPBOX_TOKEN === 'YOUR_MAPBOX_TOKEN') return [];
  
  try {
    const url = `https://api.mapbox.com/geocoding/v5/mapbox.places/${encodeURIComponent(query)}.json?access_token=${MAPBOX_TOKEN}&limit=${limit}&autocomplete=true`;
    const res = await fetch(url);
    const data = await res.json();
    if (data.features) {
      return data.features.map(item => ({
        display_name: item.place_name,
        lat: item.center[1],
        lon: item.center[0]
      }));
    }
    return [];
  } catch (error) { return []; }
}

async function reverseGeocode(lat, lon) {
  const MAPBOX_TOKEN = 'pk.eyJ1IjoiaGFpaGxlIiwiYSI6ImNtZnZkZWF0azA2YmkyeXBqOW15MnpyYmsifQ._VgiLAueIm7KWmZLY5hGTQ';
  
  if (!MAPBOX_TOKEN || MAPBOX_TOKEN === 'YOUR_MAPBOX_TOKEN') {
    try {
      const url = `https://nominatim.openstreetmap.org/reverse?format=json&lat=${lat}&lon=${lon}`;
      const res = await fetch(url);
      return await res.json();
    } catch (error) { return null; }
  }
  
  try {
    const url = `https://api.mapbox.com/geocoding/v5/mapbox.places/${lon},${lat}.json?access_token=${MAPBOX_TOKEN}`;
    const res = await fetch(url);
    const data = await res.json();
    if (data.features && data.features.length > 0) {
      return { display_name: data.features[0].place_name };
    }
    return null;
  } catch (error) {
    try {
      const url = `https://nominatim.openstreetmap.org/reverse?format=json&lat=${lat}&lon=${lon}`;
      const res = await fetch(url);
      return await res.json();
    } catch (e) { return null; }
  }
}

document.addEventListener('DOMContentLoaded', function(){
  const useBtn = document.getElementById('use-my-location-filter');
  const latInput = document.getElementById('filter-lat');
  const lonInput = document.getElementById('filter-lon');
  const locInput = document.getElementById('filter-location');
  const radiusSelect = document.getElementById('filter-radius');
  const dropdown = document.getElementById('autocomplete-dropdown');

  // preserve selected radius if present in query string
  const params = new URLSearchParams(window.location.search);
  if (params.get('radius')) {
    radiusSelect.value = params.get('radius');
  }
  if (params.get('lat')) latInput.value = params.get('lat');
  if (params.get('lon')) lonInput.value = params.get('lon');

  // Autocomplete functionality
  let searchTimeout = null;
  let currentSuggestions = [];
  let selectedIndex = -1;

  function hideDropdown() {
    if (dropdown) {
      dropdown.style.display = 'none';
      selectedIndex = -1;
    }
  }

  function showDropdown() {
    if (dropdown) {
      dropdown.style.display = 'block';
    }
  }

  function updateSelectedItem() {
    if (!dropdown) return;
    const items = dropdown.querySelectorAll('.autocomplete-item');
    items.forEach((item, index) => {
      item.classList.toggle('selected', index === selectedIndex);
    });
  }

  async function handleSearch() {
    if (!locInput || !dropdown) return;
    
    const query = locInput.value.trim();
    if (query.length < 3) {
      hideDropdown();
      return;
    }

    const suggestions = await searchAddresses(query);
    currentSuggestions = suggestions;
    
    if (suggestions.length === 0) {
      hideDropdown();
      return;
    }

    dropdown.innerHTML = '';
    suggestions.forEach((suggestion, index) => {
      const item = document.createElement('div');
      item.className = 'autocomplete-item';
      item.textContent = suggestion.display_name;
      item.addEventListener('click', () => {
        selectSuggestion(suggestion);
      });
      dropdown.appendChild(item);
    });
    
    selectedIndex = -1;
    showDropdown();
  }

  function selectSuggestion(suggestion) {
    if (locInput) locInput.value = suggestion.display_name;
    if (latInput) latInput.value = suggestion.lat;
    if (lonInput) lonInput.value = suggestion.lon;
    hideDropdown();
  }

  // Event listeners for autocomplete
  if (locInput && dropdown) {
    locInput.addEventListener('input', () => {
      if (searchTimeout) clearTimeout(searchTimeout);
      searchTimeout = setTimeout(handleSearch, 300);
    });

    locInput.addEventListener('keydown', (e) => {
      if (dropdown.style.display === 'none') return;
      
      const items = dropdown.querySelectorAll('.autocomplete-item');
      
      if (e.key === 'ArrowDown') {
        e.preventDefault();
        selectedIndex = Math.min(selectedIndex + 1, items.length - 1);
        updateSelectedItem();
      } else if (e.key === 'ArrowUp') {
        e.preventDefault();
        selectedIndex = Math.max(selectedIndex - 1, -1);
        updateSelectedItem();
      } else if (e.key === 'Enter') {
        e.preventDefault();
        if (selectedIndex >= 0 && currentSuggestions[selectedIndex]) {
          selectSuggestion(currentSuggestions[selectedIndex]);
        }
      } else if (e.key === 'Escape') {
        hideDropdown();
      }
    });

    locInput.addEventListener('focus', () => {
      if (currentSuggestions.length > 0 && locInput.value.length >= 3) {
        showDropdown();
      }
    });

    document.addEventListener('click', (e) => {
      if (!locInput.contains(e.target) && !dropdown.contains(e.target)) {
        hideDropdown();
      }
    });
  }

  useBtn.addEventListener('click', async function(e){
    e.preventDefault();
    if (!navigator.geolocation) return alert('Geolocation not supported in this browser');
    useBtn.disabled = true;
    useBtn.textContent = 'Detecting...';
    
    navigator.geolocation.getCurrentPosition(async function(pos){
      const lat = pos.coords.latitude.toFixed(6);
      const lon = pos.coords.longitude.toFixed(6);
      latInput.value = lat;
      lonInput.value = lon;
      
      try {
        const result = await reverseGeocode(parseFloat(lat), parseFloat(lon));
        if (result && result.display_name) {
          locInput.value = result.display_name;
        } else {
          locInput.value = '';
        }
      } catch (e) {
        locInput.value = '';
      }
      
      useBtn.disabled = false;
      useBtn.textContent = 'Use my location';
      hideDropdown();
      document.getElementById('filters-form').submit();
    }, function(err){
      useBtn.disabled = false;
      useBtn.textContent = 'Use my location';
      alert('Unable to get your location: ' + (err.message || err.code));
    });
  });

  // When submitting, geocode if needed
  document.getElementById('filters-form').addEventListener('submit', async function(e){
    const loc = locInput.value.trim();
    if (loc && !latInput.value && !lonInput.value) {
      hideDropdown();
      const place = await geocodeQuery(loc);
      if (place) {
        latInput.value = place.lat;
        lonInput.value = place.lon;
      }
    }
  });
});
</script>
{% endblock %}
