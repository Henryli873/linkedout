{% extends 'base.html' %}

{% block extra_css %}
<style>
/* Bottom corner popup styling */
.apply-popup {
  position: fixed;
  right: 20px;
  bottom: 20px;
  width: 360px;
  z-index: 1200;
}

/* Autocomplete dropdown styling */
.search-container { position: relative; }
.autocomplete-dropdown {
  position: absolute;
  top: 100%;
  left: 0;
  right: 0;
  background: white;
  border: 1px solid #ddd;
  border-top: none;
  border-radius: 0 0 4px 4px;
  max-height: 200px;
  overflow-y: auto;
  z-index: 1300;
  display: none;
}
.autocomplete-item {
  padding: 8px 12px;
  cursor: pointer;
  border-bottom: 1px solid #eee;
  font-size: 14px;
}
.autocomplete-item:hover {
  background-color: #f8f9fa;
}
.autocomplete-item:last-child {
  border-bottom: none;
}
.autocomplete-item.selected {
  background-color: #e9ecef;
}
</style>
{% endblock %}

{% block content %}
<div class="apply-popup">
  <div class="card shadow">
    <div class="card-header d-flex justify-content-between align-items-center">
      <strong>Apply to {{ job.title }}</strong>
      <a href="{% url 'jobs:job_detail' job.pk %}" class="btn btn-sm btn-link">Close</a>
    </div>
    <div class="card-body">
      <form method="post" enctype="multipart/form-data">
        {% csrf_token %}
  {{ form.applicant_latitude }}
  {{ form.applicant_longitude }}
        <div class="mb-2">
          <label class="form-label">Your location (optional)</label>
          <div class="search-container">
            {{ form.applicant_location }}
            <div id="autocomplete-dropdown" class="autocomplete-dropdown"></div>
          </div>
          <div class="form-text">Type a city or address to place yourself on the map (optional).</div>
        </div>
        <div class="mb-2">
          {{ form.cover_letter_text }}
        </div>
        <div class="mb-2">
          <label class="form-label">Or upload PDF cover letter</label>
          {{ form.cover_letter_file }}
          {% for err in form.cover_letter_file.errors %}
            <div class="invalid-feedback d-block">{{ err }}</div>
          {% endfor %}
        </div>
        <div class="d-flex justify-content-between">
          <button name="skip" value="1" class="btn btn-outline-secondary">Skip cover letter</button>
          <button id="submit-application" type="submit" class="btn btn-primary">Submit application</button>
        </div>
      </form>
    </div>
  </div>
</div>
<script>
// MapBox API functions for job application autocomplete
async function geocodeOnce(query) {
  if (!query) return null;
  
  // MapBox API token
  const MAPBOX_TOKEN = 'pk.eyJ1IjoiaGFpaGxlIiwiYSI6ImNtZnZkZWF0azA2YmkyeXBqOW15MnpyYmsifQ._VgiLAueIm7KWmZLY5hGTQ';
  
  if (!MAPBOX_TOKEN || MAPBOX_TOKEN === 'YOUR_MAPBOX_TOKEN') {
    // Fallback to Nominatim
    try {
      const url = `https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(query)}`;
      const res = await fetch(url);
      const data = await res.json();
      return data && data.length ? {
        lat: parseFloat(data[0].lat),
        lon: parseFloat(data[0].lon)
      } : null;
    } catch (e) {
      console.warn('Geocode error', e);
      return null;
    }
  }
  
  // Use MapBox Geocoding API
  try {
    const url = `https://api.mapbox.com/geocoding/v5/mapbox.places/${encodeURIComponent(query)}.json?access_token=${MAPBOX_TOKEN}&limit=1`;
    const res = await fetch(url);
    const data = await res.json();
    
    if (data.features && data.features.length > 0) {
      const item = data.features[0];
      return {
        lat: item.center[1], // MapBox returns [lng, lat]
        lon: item.center[0]
      };
    }
    return null;
  } catch (error) {
    console.error('Error geocoding:', error);
    return null;
  }
}

async function searchAddresses(query, limit = 5) {
  if (query.length < 3) return [];
  
  // MapBox API token
  const MAPBOX_TOKEN = 'pk.eyJ1IjoiaGFpaGxlIiwiYSI6ImNtZnZkZWF0azA2YmkyeXBqOW15MnpyYmsifQ._VgiLAueIm7KWmZLY5hGTQ';
  
  if (!MAPBOX_TOKEN || MAPBOX_TOKEN === 'YOUR_MAPBOX_TOKEN') {
    console.error('MapBox API token not configured.');
    return [];
  }
  
  // Use MapBox Geocoding API for address suggestions (supports autocomplete)
  const url = `https://api.mapbox.com/geocoding/v5/mapbox.places/${encodeURIComponent(query)}.json?access_token=${MAPBOX_TOKEN}&limit=${limit}&autocomplete=true`;
  
  try {
    const res = await fetch(url);
    const data = await res.json();
    
    if (data.features) {
      return data.features.map(item => ({
        display_name: item.place_name,
        lat: item.center[1], // MapBox returns [lng, lat]
        lon: item.center[0]
      }));
    }
    return [];
  } catch (error) {
    console.error('Error fetching addresses:', error);
    return [];
  }
}

// DOM elements
const locInput = document.querySelector('[name="applicant_location"]');
const latInput = document.querySelector('[name="applicant_latitude"]');
const lonInput = document.querySelector('[name="applicant_longitude"]');
const dropdown = document.getElementById('autocomplete-dropdown');

// Autocomplete functionality
let searchTimeout = null;
let currentSuggestions = [];
let selectedIndex = -1;

function hideDropdown() {
  if (dropdown) {
    dropdown.style.display = 'none';
    selectedIndex = -1;
  }
}

function showDropdown() {
  if (dropdown) {
    dropdown.style.display = 'block';
  }
}

function updateSelectedItem() {
  if (!dropdown) return;
  const items = dropdown.querySelectorAll('.autocomplete-item');
  items.forEach((item, index) => {
    item.classList.toggle('selected', index === selectedIndex);
  });
}

async function handleSearch() {
  if (!locInput || !dropdown) return;
  
  const query = locInput.value.trim();
  if (query.length < 3) {
    hideDropdown();
    return;
  }

  const suggestions = await searchAddresses(query);
  currentSuggestions = suggestions;
  
  if (suggestions.length === 0) {
    hideDropdown();
    return;
  }

  dropdown.innerHTML = '';
  suggestions.forEach((suggestion, index) => {
    const item = document.createElement('div');
    item.className = 'autocomplete-item';
    item.textContent = suggestion.display_name;
    item.addEventListener('click', () => {
      selectSuggestion(suggestion);
    });
    dropdown.appendChild(item);
  });
  
  selectedIndex = -1;
  showDropdown();
}

function selectSuggestion(suggestion) {
  if (locInput) locInput.value = suggestion.display_name;
  if (latInput) latInput.value = suggestion.lat;
  if (lonInput) lonInput.value = suggestion.lon;
  hideDropdown();
}

// Event listeners for autocomplete
if (locInput && dropdown) {
  locInput.addEventListener('input', () => {
    if (searchTimeout) clearTimeout(searchTimeout);
    searchTimeout = setTimeout(handleSearch, 300); // Debounce search
  });

  locInput.addEventListener('keydown', (e) => {
    if (dropdown.style.display === 'none') return;
    
    const items = dropdown.querySelectorAll('.autocomplete-item');
    
    if (e.key === 'ArrowDown') {
      e.preventDefault();
      selectedIndex = Math.min(selectedIndex + 1, items.length - 1);
      updateSelectedItem();
    } else if (e.key === 'ArrowUp') {
      e.preventDefault();
      selectedIndex = Math.max(selectedIndex - 1, -1);
      updateSelectedItem();
    } else if (e.key === 'Enter') {
      e.preventDefault();
      if (selectedIndex >= 0 && currentSuggestions[selectedIndex]) {
        selectSuggestion(currentSuggestions[selectedIndex]);
      }
    } else if (e.key === 'Escape') {
      hideDropdown();
    }
  });

  locInput.addEventListener('focus', () => {
    if (currentSuggestions.length > 0 && locInput.value.length >= 3) {
      showDropdown();
    }
  });

  // Hide dropdown when clicking outside
  document.addEventListener('click', (e) => {
    if (!locInput.contains(e.target) && !dropdown.contains(e.target)) {
      hideDropdown();
    }
  });
}

// Form submission with geocoding
document.getElementById('submit-application').addEventListener('click', async function(e){
  if (locInput && locInput.value && (!latInput.value || !lonInput.value)) {
    // Hide dropdown during submission
    hideDropdown();
    
    // attempt geocode
    const place = await geocodeOnce(locInput.value);
    if (place) {
      latInput.value = place.lat;
      lonInput.value = place.lon;
    }
  }
  // allow form to submit
});
</script>
{% endblock %}
